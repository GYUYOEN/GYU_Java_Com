
-- SET SERVEROUTPUT ON; -- SQL에서는 출력 하기 위해서 꼭 작성해줘야함
-- SET SERVEROUTPUT OFF; : 출력값이 안나옴
DECLARE
	VAR1 NUMBER;
	VAR2 VARCHAR2(30);
	VAR3 VARCHAR2(30);
BEGIN
	VAR1 := 100;
	VAR2 := 'Hello';
	VAR3 := &VAR3; -- 사용자 입력을 받아서 저장

	DBMS_OUTPUT.PUT_LINE(VAR1);
	DBMS_OUTPUT.PUT_LINE(VAR2);
	DBMS_OUTPUT.PUT_LINE(VAR3);
END;

/*
 * := 할당 연산자(= 산술 연산자) 
 */

DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	IF(VAR1 > 10) THEN
		DBMS_OUTPUT.PUT_LINE('10보다 큰 값을 입력했습니다.');
	ELSIF(VAR1 = 10) THEN
		DBMS_OUTPUT.PUT_LINE('10을 입력했습니다.');
	ELSE
		DBMS_OUTPUT.PUT_LINE('10보다 작은 값을 입력했습니다.');
	END IF;
END;

DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	IF(MOD(VAR1, 2) = 0) THEN -- 함수도 넣기 가능(MOD 나머지 구함)
		DBMS_OUTPUT.PUT_LINE('짝수입니다.');
	ELSE
		DBMS_OUTPUT.PUT_LINE('홀수입니다.');
	END IF;
END;

DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	-- LOOP : 반복문(while 문과 비슷)
	-- LOOP만 사용하면 무한반복
	LOOP
		DBMS_OUTPUT.PUT_LINE(VAR1);
		IF(VAR1 = 0) THEN 
			EXIT;
		END IF;
		VAR1 := VAR1 - 1;
	END LOOP;
END;

DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;

	-- 0..VAR1 : 반복횟수 (0 에서 VAR1까지 반복)
	-- FOR : 일정횟수 반복
	-- 자동감소 x, 같은수가 계속 반복됨
	-- I : IN에 해당하는 인덱스 (0..4 : 0, 1, 2, 3, 4)
	FOR I IN 0..VAR1 LOOP
		DBMS_OUTPUT.PUT_LINE(VAR1 || '/' || I);
	END LOOP;
END;

DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	
	-- REVERSE : 역으로 I 출력(0..4 : 4, 3, 2, 1, 0)
	FOR I IN REVERSE 3..10 LOOP
		DBMS_OUTPUT.PUT_LINE(VAR1 || '/' || I);
	END LOOP;
END;

DECLARE
	VAR1 NUMBER;
	USER_INPUT NUMBER;
BEGIN
	VAR1 := &USER_INPUT;
	-- WHILE : 조건에 따라 반복
	-- VAR1 > 0 이면 반복
	WHILE VAR1 > 0 LOOP
		DBMS_OUTPUT.PUT_LINE(VAR1);
		VAR1 := VAR1 - 1;
	END LOOP;
END;

DECLARE
	EMP_ID NUMBER;
	EMP_NAME1 VARCHAR2(50);
	EMP_NAME2 VARCHAR2(50);
	USER_INPUT NUMBER;
BEGIN
		-- SELECT에 조회한 결과를 INTO에 넣어라
		SELECT EMPLOYEE_ID
			 , FIRST_NAME
			 , LAST_NAME
		-- INTO : 변수정의, SELECT에 조회한것을 이곳에 넣음
		-- 예) EMPLOYEE_ID -> EMP_ID, FIRST_NAME -> EMP_NAME1 ...
	  	 INTO EMP_ID, EMP_NAME1, EMP_NAME2
	  	 FROM EMPLOYEES
	 	WHERE EMPLOYEE_ID = &USER_INPUT;
	
		DBMS_OUTPUT.PUT_LINE(EMP_ID);
		DBMS_OUTPUT.PUT_LINE(EMP_NAME1);
		DBMS_OUTPUT.PUT_LINE(EMP_NAME2);
END;

DECLARE
	EMP_ID NUMBER;
	EMP_NAME1 VARCHAR2(50);
	EMP_NAME2 VARCHAR2(50);
BEGIN
	FOR ID IN 100..199 LOOP	
		SELECT EMPLOYEE_ID
			 , FIRST_NAME
			 , LAST_NAME
	  	 INTO EMP_ID, EMP_NAME1, EMP_NAME2
	  	 FROM EMPLOYEES
	 	WHERE EMPLOYEE_ID = ID;
	
		DBMS_OUTPUT.PUT_LINE(EMP_ID || ', ' || EMP_NAME1 || ', ' || EMP_NAME2);
	END LOOP;
END;

-- 1개의 행만 저장 가능
DECLARE
	-- EMPLOYEES 테이블에 EMPLOYEE_ID 가 가지는 타입으로 만듬(타입 직접 지정 X)
	EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
	EMP_NAME1 EMPLOYEES.FIRST_NAME%TYPE;
	EMP_NAME2 EMPLOYEES.LAST_NAME%TYPE;
BEGIN
	FOR ID IN 100..199 LOOP
		SELECT EMPLOYEE_ID
			 , FIRST_NAME
			 , LAST_NAME
	  	INTO EMP_ID, EMP_NAME1, EMP_NAME2
	  	FROM EMPLOYEES
	 	WHERE EMPLOYEE_ID = ID;
	
		DBMS_OUTPUT.PUT_LINE(EMP_ID || ', ' || EMP_NAME1 || ', ' || EMP_NAME2);
	END LOOP;
END;

-- 1개의 행만 저장 가능(EMPLOYEE_ID = ID)
DECLARE
	-- ROWTYPE : MPLOYEES 테이블의 한 행의 데이터 타입을 ROW_DATA에 넣는다
    ROW_DATA EMPLOYEES%ROWTYPE;
BEGIN
	FOR ID IN 100..199 LOOP
		-- SELECT에 조회한 결과를 INTO에 넣어라
		SELECT *
          INTO ROW_DATA
          FROM EMPLOYEES
         WHERE EMPLOYEE_ID = ID;
		-- ROW_DATA.EMPLOYEEE_ID : ROW_DATA의 EMPLOYEE_ID가 무엇인지
		 DBMS_OUTPUT.PUT_LINE(ROW_DATA.EMPLOYEE_ID ||
            ', ' || ROW_DATA.FIRST_NAME || ', ' ||ROW_DATA.LAST_NAME);
    END LOOP;
END;

-- 배열처럼 n행의 데이터를 넣는 방법
-- ID만 출력
DECLARE
-- 배열타입 생성, 오라클에서는 테이블 타입
-- EMPLOYEES.EMPLOYEE_ID%TYPE : 배열에 저장할 데이터 타입 명시
-- INDEX BY BINARY_INTEGER : 인덱스로 사용할 타입 지정(BINARY_INTEGER : 숫자타입)
-- EMP_ID_TABLE_TYPE : 타입이름(명) 지정해줌(변수명 처럼 지어줌)
-- EMP_IDS : 변수명
	-- 타입만 지정, 변수선언 X
	TYPE EMP_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.EMPLOYEE_ID%TYPE
							  INDEX BY BINARY_INTEGER;
	-- 위에 생성한 테이블 타입을 사용할 변수 선언
	EMP_IDS   EMP_ID_TABLE_TYPE;
	-- 초기값 0 지정 : 인덱스 0부터 사용하게 지정
	IDX 	  BINARY_INTEGER := 0;
BEGIN
	FOR R_DATA IN (SELECT EMPLOYEE_ID
					 FROM EMPLOYEES
					WHERE EMPLOYEE_ID BETWEEN 100 AND 199) LOOP
		IDX := IDX + 1;
		EMP_IDS(IDX) := R_DATA.EMPLOYEE_ID; -- INDEX 번호 1번부터 진행
		
		DBMS_OUTPUT.PUT_LINE(EMP_IDS(IDX));
	END LOOP;
END;

-- 배열처럼 n행의 데이터를 넣는 방법
DECLARE
	TYPE EMP_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.EMPLOYEE_ID%TYPE
							  INDEX BY BINARY_INTEGER;
	TYPE EMP_NAME_TABLE_TYPE IS TABLE OF EMPLOYEES.FIRST_NAME%TYPE
							  	INDEX BY BINARY_INTEGER;	
	EMP_IDS   EMP_ID_TABLE_TYPE;
	EMP_NAMES EMP_NAME_TABLE_TYPE;
	IDX 	  BINARY_INTEGER := 0;
BEGIN
	-- SELECT 구문은 한번만 조회, 반복문X
	-- 한번 조회할 때 SELECT의 Result Set을 가져다가 한행씩 R_DATA에 넣어줌
	FOR R_DATA IN (SELECT EMPLOYEE_ID, FIRST_NAME 
				 	 FROM EMPLOYEES
					WHERE EMPLOYEE_ID BETWEEN 100 AND 199) LOOP
		IDX := IDX + 1;
		EMP_IDS(IDX) := R_DATA.EMPLOYEE_ID; -- INDEX 번호 1번부터 진행
		EMP_NAMES(IDX) := R_DATA.FIRST_NAME;
	
	DBMS_OUTPUT.PUT_LINE(EMP_IDS(IDX) || ', ' || EMP_NAMES(IDX));
	END LOOP;
END;


-- 배열에 담아놓고 나중에 반복문 사용하여 출력
DECLARE
	TYPE EMP_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.EMPLOYEE_ID%TYPE
							  INDEX BY BINARY_INTEGER;
	TYPE EMP_NAME_TABLE_TYPE IS TABLE OF EMPLOYEES.FIRST_NAME%TYPE
							  	INDEX BY BINARY_INTEGER;	
	EMP_IDS   EMP_ID_TABLE_TYPE;
	EMP_NAMES EMP_NAME_TABLE_TYPE;
	IDX 	  BINARY_INTEGER := 0;
BEGIN
	FOR R_DATA IN (SELECT EMPLOYEE_ID, FIRST_NAME 
				 	 FROM EMPLOYEES
					WHERE EMPLOYEE_ID BETWEEN 100 AND 199) LOOP
		IDX := IDX + 1;
		EMP_IDS(IDX) := R_DATA.EMPLOYEE_ID; -- INDEX 번호 1번부터 진행
		EMP_NAMES(IDX) := R_DATA.FIRST_NAME;
	END LOOP;
	
	-- COUNT : 배열에 저장된 데이터의 수를 세어줌
	-- 크기가 같으므로 EMP_NAMES 써도 상관없음
	FOR I IN 1..EMP_IDS.COUNT LOOP
		DBMS_OUTPUT.PUT_LINE(EMP_IDS(I) || ', ' || EMP_NAMES(I));
	END LOOP;
	
END;

-- 배열에 행 데이터를 넣어줌
-- 1 컬럼(열)을 출력함(SELECT EMPLOYEE_ID, FIRST_NAME)
DECLARE
	TYPE EMP_ROW_TABLE_TYPE IS TABLE OF EMPLOYEES%ROWTYPE
							  INDEX BY BINARY_INTEGER;
	EMP_ROWS   EMP_ROW_TABLE_TYPE;
	IDX 	  BINARY_INTEGER := 0;
BEGIN
	-- 조회한 내용을 반복문 사용해서 집어 넣어줌 (여전히 배열 형태)
	FOR R_DATA IN (SELECT *
				 	 FROM EMPLOYEES
					WHERE EMPLOYEE_ID BETWEEN 100 AND 199) LOOP
		IDX := IDX + 1;
		EMP_ROWS(IDX) := R_DATA;
	END LOOP;
	
	FOR I IN 1..EMP_ROWS.COUNT LOOP
	 DBMS_OUTPUT.PUT_LINE(EMP_ROWS(I).EMPLOYEE_ID || 
		', ' || EMP_ROWS(I).FIRST_NAME);
	END LOOP;
END;

-- 레코드 타입 (여러 행 데이터 X)
-- 1개의 행 N열에 대한 정보
-- JOIN을 시켜줄 때 사용
-- 1 컬럼(열) -> N 열
DECLARE
    TYPE EMP_RECORD_TYPE IS RECORD (
         ID          EMPLOYEES.EMPLOYEE_ID%TYPE
       , FIRST_NAME  EMPLOYEES.FIRST_NAME%TYPE
       , LAST_NAME   EMPLOYEES.LAST_NAME%TYPE
       , SALARY      EMPLOYEES.SALARY%TYPE
       , DEPART_ID   DEPARTMENTS.DEPARTMENT_ID%TYPE
       , DEPART_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE
    );
   
    TYPE EMP_TABLE_TYPE IS TABLE OF EMP_RECORD_TYPE INDEX BY BINARY_INTEGER;

    EMP_TABLE   EMP_TABLE_TYPE;
    IDX BINARY_INTEGER := 0;
BEGIN
    FOR D IN (SELECT E.EMPLOYEE_ID
                   , E.FIRST_NAME
                   , E.LAST_NAME
                   , E.SALARY
                   , D.DEPARTMENT_ID
                   , D.DEPARTMENT_NAME
                FROM EMPLOYEES E JOIN DEPARTMENTS D
                  ON E.DEPARTMENT_ID = D.DEPARTMENT_ID) LOOP
        IDX := IDX + 1;
        EMP_TABLE(IDX) := D;
    END LOOP;
    
    FOR REC IN 1..EMP_TABLE.COUNT LOOP
    	DBMS_OUTPUT.PUT_LINE(EMP_TABLE(REC).ID);
    END LOOP;
END;

-- SELECT INTO 구문에 모든 행 데이터 담을 수 있음
-- N행 N열
DECLARE
    TYPE EMP_TABLE_TYPE IS TABLE OF PUSER1.EMPLOYEES%ROWTYPE;
 
    EMP_RECORDS   EMP_TABLE_TYPE;
BEGIN
    SELECT * BULK COLLECT INTO EMP_RECORDS FROM PUSER1.EMPLOYEES;
    
    FOR R IN 1..EMP_RECORDS.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE(EMP_RECORDS(R).FIRST_NAME);
    END LOOP;
END;


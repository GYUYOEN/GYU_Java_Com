-- ORDER BY : 정렬
-- 실행 순서 : FROM > WHERE > SELECT > ORDER BY
-- ORDER BY 가장 마지막에 수행 : 컬럼명뿐만아니라  
-- 별칭(NAME), 컬럼순번으로도 지정해 줄 수 있음.
SELECT EMPLOYEE_ID
	 , FIRST_NAME || ' ' || LAST_NAME AS NAME
	 , SALARY
	 , COMMISSION_PCT 
	 , HIRE_DATE
  FROM EMPLOYEES
 WHERE COMMISSION_PCT IS NULL
 -- ASC : 오름차순, DESC : 내림차순
 -- 아무것도 안쓰면 오름차순으로 정렬됨
 -- 급여에 대해서는 내림차순인데 급여가 동일하면 이름에 대해서는 오름차순으로 정렬
 ORDER BY SALARY DESC, NAME;
-- ORDER BY SALARY; : 컬럼명
-- ORDER BY NAME DESC; : 별칭
-- ORDER BY 3 DESC; : 컬럼순번

SELECT EMPLOYEE_ID
	 , FIRST_NAME || ' ' || LAST_NAME AS NAME
	 , SALARY
	 , COMMISSION_PCT 
	 , HIRE_DATE
  FROM EMPLOYEES
 ORDER BY SALARY, NAME DESC;

SELECT EMPLOYEE_ID
     , FIRST_NAME || ' ' || LAST_NAME AS NAME
     , SALARY
     , COMMISSION_PCT
     , HIRE_DATE
  FROM EMPLOYEES
 ORDER BY NAME DESC;
 
SELECT EMPLOYEE_ID
	 , FIRST_NAME || ' ' || LAST_NAME AS NAME
	 , SALARY
	 , COMMISSION_PCT 
	 , HIRE_DATE
  FROM EMPLOYEES
 -- NULLS FIRST : NULL 데이터들을 제일 처음에 정렬
 -- NULLS LAST : NULL 데이터들을 제일 마지막에 정렬
 ORDER BY 4 NULLS FIRST;
 
SELECT EMPLOYEE_ID
	 , FIRST_NAME || ' ' || LAST_NAME AS NAME
	 , SALARY
	 , COMMISSION_PCT 
	 , HIRE_DATE
  FROM EMPLOYEES
 -- 일반적으로 오름차순 정렬 -> 정렬방식 없이 SALARY만 적으면 오름차순
 ORDER BY SALARY, 4 NULLS LAST;

-- DISTINCT : 중복을 제거해줌
SELECT DISTINCT DEPARTMENT_ID
  FROM EMPLOYEES;
 
-- FROM > WHERE > GROUP BY > SELECT > ORDER BY 순으로 실행
SELECT DEPARTMENT_ID
	 , MIN(SALARY)
	 , MAX(SALARY)
	 , AVG(SALARY)
	 , SUM(SALARY)
	 , COUNT(SALARY)
  FROM EMPLOYEES
 -- DEPARTMENT_ID 에서 같은 숫자끼리 묶고 묶은 것끼리에 대한 최소값, 최대값, 평균 ... 등을 구함
 GROUP BY DEPARTMENT_ID
 ORDER BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID
	 , JOB_ID
	 , MIN(SALARY)
	 , MAX(SALARY)
	 , AVG(SALARY)
	 , SUM(SALARY)
	 , COUNT(SALARY)
  FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID, JOB_ID
 ORDER BY DEPARTMENT_ID;
  
-- 묶임 그룸으로 출력이 되어야 하기 때문에 그냥 HIRE_DATE 쓰면 오류남
-- GROUP BY에 쓰인거 그대로 SELECT에 쓰여야함
SELECT EXTRACT(YEAR FROM HIRE_DATE) AS 고용년
	 , MIN(SALARY)
	 , MAX(SALARY)
	 , AVG(SALARY)
	 , SUM(SALARY)
	 , COUNT(SALARY)
  FROM EMPLOYEES
 GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
 -- HAVING(그룹조건) = WHERE(그룹절)
 -- 1 빼고 출력
 HAVING COUNT(SALARY) > 1;

-- FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY
SELECT COMMISSION_PCT
	 , MIN(SALARY) AS "최저 급여"
	 , MAX(SALARY) AS "최고 급여"
	 , AVG(SALARY) AS "평균 급여"
	 , SUM(SALARY) AS "급여 총합"
	 , COUNT(SALARY) AS "인원수"
  FROM EMPLOYEES
 WHERE COMMISSION_PCT IS NOT NULL
   AND SALARY >= 7000
 GROUP BY COMMISSION_PCT
 HAVING AVG(SALARY) >= 9500
 ORDER BY 6;
 
/*
 * 1980 년대, 1990 년대, 2000년데 별로 그룹을 묶어서 급여의 평균과 인원수를 구한다.
 */
SELECT * FROM EMPLOYEES;

-- TRUNC : 절사
-- SELECT에 그룹 묶어서 적용
SELECT TRUNC(EXTRACT(YEAR FROM HIRE_DATE), -1) AS 년대
	 , ROUND(AVG(SALARY), 2) "평균급여"
	 , COUNT(*) "인원수"
  FROM EMPLOYEES
 GROUP BY TRUNC(EXTRACT(YEAR FROM HIRE_DATE), -1)
 ORDER BY 년대;

SELECT SUBSTR(TO_CHAR(EXTRACT(YEAR FROM HIRE_DATE)), 1, 3) || '0' AS 년대
	 , ROUND(AVG(SALARY), 2) "평균급여"
	 , COUNT(*) "인원수"
  FROM EMPLOYEES
 GROUP BY SUBSTR(TO_CHAR(EXTRACT(YEAR FROM HIRE_DATE)), 1, 3) || '0'
 ORDER BY 년대;

SELECT FLOOR(EXTRACT(YEAR FROM HIRE_DATE) / 10) * 10 AS 년대
	 , ROUND(AVG(SALARY), 2) "평균급여"
	 , COUNT(*) "인원수"
  FROM EMPLOYEES
 GROUP BY FLOOR(EXTRACT(YEAR FROM HIRE_DATE) / 10) * 10
 ORDER BY 년대;

/*
 * 급여별 집계를 위한 그룹을 다음과 같이 묶어서 총 인원수를 구한다.
 * 		2000 ~ 3500 미만 1그룹
 * 		3500 ~ 5000 미만 2그룹
 * 		5000 ~ 8000 미만 3그룹
 * 		8000 ~ 12000 미만 4그룹
 * 		12000 이상 5그룹
 */
SELECT CASE WHEN SALARY >= 2000 AND SALARY < 3500 THEN '1그룹'
  	   	    WHEN SALARY >= 3500 AND SALARY < 5000 THEN '2그룹'
	        WHEN SALARY >= 5000 AND SALARY < 8000 THEN '3그룹'
	        WHEN SALARY >= 8000 AND SALARY < 12000 THEN '4그룹'
	        WHEN SALARY >= 12000 THEN '5그룹'
	   END AS 그룹
     , COUNT(*) AS 인원수
  FROM EMPLOYEES
 GROUP BY CASE WHEN SALARY >= 2000 AND SALARY < 3500 THEN '1그룹'
  	   	       WHEN SALARY >= 3500 AND SALARY < 5000 THEN '2그룹'
	           WHEN SALARY >= 5000 AND SALARY < 8000 THEN '3그룹'
	           WHEN SALARY >= 8000 AND SALARY < 12000 THEN '4그룹'
	           WHEN SALARY >= 12000 THEN '5그룹'
	END
 ORDER BY 그룹;

SELECT DEPARTMENT_ID
	 , JOB_ID
	 , SUM(SALARY)
	 , AVG(SALARY)
	 , COUNT(*)
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID);
 
SELECT DEPARTMENT_ID
	 , JOB_ID
	 , SUM(SALARY)
	 , AVG(SALARY)
	 , COUNT(*)
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, JOB_ID)
 ORDER BY DEPARTMENT_ID, JOB_ID NULLS LAST;
-- ROLLUP과 CUBE 위부분은 같으나 CUBE에 JOB_ID 집계가 추사됨

SELECT DEPARTMENT_ID
	 , JOB_ID
	 , DECODE(NVL(COMMISSION_PCT, 0), 0, 'NO', 'YES')
	 , SUM(SALARY)
	 , AVG(SALARY)
	 , COUNT(*)
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID, DECODE(NVL(COMMISSION_PCT, 0), 0, 'NO', 'YES'));

SELECT DEPARTMENT_ID
	 , JOB_ID
	 , DECODE(NVL(COMMISSION_PCT, 0), 0, 'NO', 'YES')
	 , SUM(SALARY)
	 , AVG(SALARY)
	 , COUNT(*)
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, JOB_ID, DECODE(NVL(COMMISSION_PCT, 0), 0, 'NO', 'YES'))
 ORDER BY DEPARTMENT_ID, JOB_ID, 3 NULLS LAST;
 

SELECT * FROM EMPLOYEES;

/*
 * 부서, 고용년도 별 급여 통계(최고 급여, 최저 급여, 평균) 를 구한다.
 * 		- ROLLUP, CUBE를 적용한다.
 * 		- 부서가 NULL 인원이 있기 때문에 해당 인원은 제외한다.
 */

SELECT DEPARTMENT_ID AS 부서
	 , EXTRACT(YEAR FROM HIRE_DATE) AS 고용년도
	 , MAX(SALARY) AS 최소급여
	 , MIN(SALARY) AS 최대급여
	 , AVG(SALARY) AS 평균급여
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP(DEPARTMENT_ID, EXTRACT(YEAR FROM HIRE_DATE))
 ORDER BY DEPARTMENT_ID, 고용년도;
 
SELECT DEPARTMENT_ID AS 부서
	 , EXTRACT(YEAR FROM HIRE_DATE) AS 고용년도
	 , MAX(SALARY) AS 최소급여
	 , MIN(SALARY) AS 최대급여
	 , AVG(SALARY) AS 평균급여
	 , CASE WHEN GROUPING(DEPARTMENT_ID) = 0 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 0 THEN '부서별/년도별'
	  		WHEN GROUPING(DEPARTMENT_ID) = 0 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 1 THEN '부서별'
	 		WHEN GROUPING(DEPARTMENT_ID) = 1 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 0 THEN '년도별'
			WHEN GROUPING(DEPARTMENT_ID) = 1 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 1 THEN '전체(총)'
	    END AS 그룹구분
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY ROLLUP(DEPARTMENT_ID, EXTRACT(YEAR FROM HIRE_DATE))
 ORDER BY DEPARTMENT_ID, 고용년도;

SELECT DEPARTMENT_ID AS 부서
	 , EXTRACT(YEAR FROM HIRE_DATE) AS 고용년도
	 , MAX(SALARY) AS 최소급여
	 , MIN(SALARY) AS 최대급여
	 , AVG(SALARY) AS 평균급여
	 , CASE WHEN GROUPING(DEPARTMENT_ID) = 0 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 0 THEN '부서별/년도별'
	  		WHEN GROUPING(DEPARTMENT_ID) = 0 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 1 THEN '부서별'
	 		WHEN GROUPING(DEPARTMENT_ID) = 1 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 0 THEN '년도별'
			WHEN GROUPING(DEPARTMENT_ID) = 1 AND GROUPING(EXTRACT(YEAR FROM HIRE_DATE)) = 1 THEN '전체(총)'
	    END AS 그룹구분
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY CUBE(DEPARTMENT_ID, EXTRACT(YEAR FROM HIRE_DATE))
 ORDER BY DEPARTMENT_ID, 고용년도;

 
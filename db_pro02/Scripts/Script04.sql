-- ROWNUM : 행번호 부여
SELECT ROWNUM
	 , EMPLOYEE_ID
	 , FIRST_NAME
	 , LAST_NAME
	 , SALARY
	 , COMMISSION_PCT
  FROM EMPLOYEES
 WHERE COMMISSION_PCT IS NOT NULL
   AND ROWNUM <= 10
 ORDER BY SALARY DESC; -- ROWNUM이 뒤죽박죽 섞임

-- 값이 다름
SELECT * 
  FROM (SELECT EMPLOYEE_ID -- 하나의 테이블
	         , FIRST_NAME
	         , LAST_NAME
	 		 , SALARY
	 		 , COMMISSION_PCT
	 	  FROM EMPLOYEES
	 	 WHERE COMMISSION_PCT IS NOT NULL
	 	 ORDER BY SALARY DESC)
 WHERE ROWNUM <= 10; 

-- WITH 에 서브 쿼리에 임시 테이블명(EMP_COM) 선정
-- 서브 쿼리가 중복이 될 때 바로 사용할 수 있도록 미리 정의
WITH EMP_COM
  AS (SELECT EMPLOYEE_ID
	         , FIRST_NAME
	         , LAST_NAME
	 		 , SALARY
	 		 , COMMISSION_PCT
	 	  FROM EMPLOYEES
	 	 WHERE COMMISSION_PCT IS NOT NULL
	 	 ORDER BY SALARY DESC)
SELECT * FROM EMP_COM;

-- RANK() OVER : 값이 동일하면 동일한 등수 부여하고 다음값은 중복된 수 + 1
-- 이미 정렬이 된 상태라 ORDER BY 안써도 됨
SELECT *
  FROM(SELECT FIRST_NAME
  			, LAST_NAME
  			, SALARY
  			, RANK() OVER(ORDER BY SALARY DESC) AS 순위
  		 FROM EMPLOYEES)
 WHERE 순위 <= 10;

-- 구지 서브쿼리로 안써도 됨
SELECT FIRST_NAME
  	 , LAST_NAME
  	 , SALARY
  	 , RANK() OVER(ORDER BY SALARY DESC) AS 순위
  FROM EMPLOYEES;

-- DENSE_RANK() OVER : 중복이 되든 안되든 등수 1씩 증가
-- 연속된 등수
-- 조건을 부여하기 위해서 서브쿼리 작성
SELECT *
  FROM(SELECT FIRST_NAME
  			, LAST_NAME
  			, SALARY
  			, DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 순위
  		 FROM EMPLOYEES)
 WHERE 순위 <= 10;
 
SELECT FIRST_NAME
  	 , LAST_NAME
  	 , SALARY
  	 , DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 순위
  FROM EMPLOYEES;
-- WHERE 순위 <= 10; : 오류 발생(순서로 인해)

-- 다중열, 단일행
SELECT * 
  FROM EMPLOYEES
 WHERE (SALARY, COMMISSION_PCT) = (SELECT SALARY, COMMISSION_PCT FROM EMPLOYEES WHERE EMPLOYEE_ID = 157);

SELECT * 
  FROM EMPLOYEES
 WHERE (SALARY, COMMISSION_PCT) = ((9500, 0.35));

-- 다중열, 다중행(IN 사용)
SELECT * 
  FROM EMPLOYEES
 WHERE (SALARY, COMMISSION_PCT) IN ((9500, 0.35), (9500, 0.25));
 